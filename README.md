HCL syntax is basic abnd should be readable by those familer with other scripting languages. It has 3 parts

1. **BLOCK**: Block group expression, arguments and other blocks into a lableable structure, which external blocks can then reference its curly bracker {} syntax is shared by most object-oriented languages.

2. **Argumnets**: Arguments are an abstraction that enable IT admins to assign values to descriptive names, which can represent or corporate values. They can be simple,such as a string or numeric value, or more complicated such as arithmatic or logical expressions.

3. **EXPRESSIONS**: Expressions either represent or compute values. Yhey can be simple, such as a string or numeric value, or more complicated, such as arithmetic, boolean, or logical expression.

#**Syntax**
BLOCK TYPE "BLOCK LABLE" "BLOCK ARGUMENTS" {
    IDENTIFIER = "EXPRESSION"
}

#**example**:
resource "aws_instance" "webserver" {
    instance_type = "t2.micro"
    }

**PROVIDER**: A Provider is responsible for understanding API interactions and exposing resources, if an API is availbal. You can create a Provider A Provider uses a plugin. In order to make a provider availble on Terraform, we need to make a "terraform init", this command will download any plugins we need for our provider. (AWS, GCP, Azure)

**MOST USED TERRAFORM COMMANDS** : 

**Terraform init** : The "terraform init" is used to initialize a working directory containing terraform configuration files. it is safe to tun this command multiple times. This command will never delete your existing configuration or state during init. The root configuration directory is consulted fir backend configuration and the choosen backend is initialized using the given configuration.(in short it is like git init, but here terraform alos inits the direcorty and downloads the provder plugins too)

**Terraform validate** : The "terraform validate" command validates the configuration files in a directory refering only to the confoguration and not accessing any remote services such as remote state, provider APIs etc. Validate runs checks that verify whetehr a configuration is syntactually valid and internally consistent, regardless of any provided variables or existing state. It is thus useful in genral verifcation of resusable modules including correctness of attribute names and value types.

**Terraform plan** : The "terraform plan" command is used to create an execution plan. terraform performs a refresh, unless expilictly disbaled and then determines what actions are neccesary to achive the desired state specified in the configuration files.

**Terraform apply** : The "terraform apply" command is used to apply the changes required to reach the desired state of the configuration or the pre-determined set of actions generated by a terraform plan execution plan

**Terraform destroy** : The "terraform destroy" command is used to destroy the terraform-manged infrastructure.

**WORKSPACES**:
Terraform lets us to use single source code to apply in different environments. to make it separe, terrafrom has workspaces and for every workspace a different state file is created in order to isolate form other workspaces.

Terrafrom by creates a default workspace while you initialize the repo

To see the workspace : "terraform workspace list"
It is best to practice to maintain dev, stage and prod environments

To create a new dev workspace : **terrafrom workspace new dev**
To create a new stage workspace : **terrafrom workspace new stage**
To create a new prod workspace : **terrafrom workspace new prod**

**Terragrunt**:
 Terragrunt is a wrapper around Terraform that solves manging large infra

**Reducing duplication** Instead of repeating backend configs, provider blocks, and common variables in every Terraform module, you can define them once in a terragrunt.hcl file.
**Managing remote state** It automatically configures and manages Terraform’s remote backend (like S3 + DynamoDB for AWS, or GCS for GCP).
**Managing dependencies**  It lets you define module dependencies (for example, your network must be deployed before your database). Terragrunt can run them in order.
**Handling multiple environments**  You can easily structure your repo 
live/
  ├── dev/
  │   ├── vpc/
  │   ├── app/
  │   └── database/
  └── prod/
      ├── vpc/
      ├── app/
      └── database/

Documentation for terragrunt: 